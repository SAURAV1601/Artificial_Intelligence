import math
import random
from copy import deepcopy
import matplotlib.pyplot as plt


#In this algorithm, a new point is generated by a simple mathematical formulae using 3 different points in the same population.
# The formulae is newpoint = a+F*(b-c) , where a,b,c are 3 random different points in given population
globalmin=10000

np=20 #population size
F=1.2 #differential factor
cr=0.3 #cross over probability
runs=[]
runMinVal=[]
noRun=100 #number of runs

#returns ackleys function value for given x,y
def ackleysufunction(x,y):
	firstvalue = -20*(math.exp(-0.2*math.sqrt(0.5*(x*x+y*y))))
	secondvalue = math.exp(0.5*(math.cos(2*math.pi*x)+math.cos(2*math.pi*y)))
	return firstvalue-secondvalue

#loop to run the algorithm for given runs
for i in range(1,noRun+1):
	localmin=10000
	populationX=[]
	populationY=[]
	flag=1
	localcount=0
	#initializing x and y population with random numbers in given domain of ackley's function
	for j in range(0,np):
		populationX.append(random.uniform(-5,5))
		populationY.append(random.uniform(-5,5))

	localcount=0
	#this loop breaks when a minimum value is not found in last 100 iterations
	while(flag):
		#calculating ackley's function value for every x and y pair in the population
		for j in range(0,np):
			value=ackleysufunction(populationX[j],populationY[j])
			#checks if the given x,y have minimum ackley's value than the existing value, if so this value is made as minimum for the run
			if value<localmin:
				localmin=value
				localMinX=populationX[j]
				localMinY=populationY[j]
				localcount=0
			#incrementing the counter to check if last 100 iterations don't have minimum than exisiting, if they do then counter is set to 0
			localcount+=1
			if localcount==100:
				flag=0
		#finding 3 different random points from population
		for j in range(0,np):
			r1=random.randint(0,19)
			r2=random.randint(0,19)
			r3=random.randint(0,19)
			while (1):
				if r1==j or r2==j or r3==j:
					r1=random.randint(0,19)
					r2=random.randint(0,19)
					r3=random.randint(0,19)
				else:
					break


			mutX = populationX[j]
			mutY = populationY[j]
			R = random.randint(0,3)
			r=random.uniform(0,1)
			#checking for crossover probability, if yes then new point is generated
			if r<cr or R==0:
				mutX=populationX[r1]+F*(populationX[r2]-populationX[r3])
			
			r=random.uniform(0,1)
			if r<cr or R==1:
				mutY=populationY[r1]+F*(populationY[r2]-populationY[r3])
			
			#check if old point is better or not and place the better point in population
			if ackleysufunction(mutX,mutY) < ackleysufunction(populationX[j],populationY[j]):
				populationX[j] = mutX
				populationY[j] = mutY
	#adds minimum ackley's value to a list on each run
	runs.append(i)
	runMinVal.append(localmin)
	if localmin<globalmin:
		globalmin=localmin
		globalMinX=localMinX
		globalMinY=localMinY

#uncomment below line to display minima of ackley's functions in all the runs
# print globalMinX,globalMinY,globalmin
#Displaying the line chart for minimum in each run
fig = plt.figure(figsize=(11,8))
ax1 = fig.add_subplot(111)

ax1.plot(runs, runMinVal, label='Component 1', color='c', marker='o')
plt.xticks(runs)
plt.xticks(rotation=90)
plt.xlabel('Runs')
plt.show()
plt.savefig('diff_evolution.png')
